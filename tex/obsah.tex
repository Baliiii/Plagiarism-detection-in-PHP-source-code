%=========================================================================
% (c) Michal Bidlo, Bohuslav Køena, 2008

\chapter{Úvod}
Plagiátorství je záva¾ným problémem nejen ve vzdìlávacích a~vìdeckých institucích a má velmi dlouhou a~bohatou historii. 
Mezinárodní norma ÈSN ISO 5127-2003 jej popisuje jako pøedstavení du¹evního díla jiného autora, pùjèeného nebo napodobeného 
vcelku nebo zèásti, jako svého vlastního. Nicménì nejvíce pøípadù plagiátorství se stále nachází v~akademických institucích, 
kde studenti kopírují své práce mezi sebou, v~pøesvìdèení, ¾e zahladili v¹echny stopy vedoucí k odhalení plagiátu.

Pokud se zamìøíme èistì na plagiáty ve zdrojových kódech, mù¾eme je definovat jako program, který byl vytvoøený z~jiného programu tak, aby na první pohled nebylo mo¾né rozeznat originál od kopie. Mezi základní transformace zdrojového kódu, tedy ty, na které se tato práce zamìøuje mù¾eme oznaèit zmìnu komentáøù, identifikátorù, øídících struktur, restrukturalizaci zdrojového kódu nebo zmìnu toku programu (výmìna podmínek ve vyhodnocení {\tt if-else}).

V rámci této bakaláøské práce se pokusím ukázat zpùsoby, jak odhalit právì plagiáty studentských prací napsaných v jazyce PHP a~poukázat na problémy, ke kterým mù¾e pøi automatické detekci plagiátorství docházet.

\section{Plagiátorství}
Jak ji¾ bylo uvedeno vý¹e, plagiátorství je na akademické pùdì záva¾ným problémem a tudí¾ by mìlo být i~pøíslu¹nì potrestáno. Nicménì plagiátorství zdrojových kódu sebou pøiná¹í nìkolik problému, které znaènì stì¾ují schopnost odli¹it plagiát od~originálu. Tyto problémy mù¾eme rozli¹it do ¹esti kategorií (Figure 1.1), z nich¾ pouze jednu mù¾eme oznaèit jako plagiát.
\begin{itemize}
\item \textbf{Zdrojový kód tøetích stran}, kterým jsou my¹leny rùzné open-source kódy pøípadnì rùzné knihovny.
\item \textbf{Nástroje na automatické generování kódu}, kde jako pøíklad mù¾eme uvést vývojové prostøedí Netbeans IDE, které automaticky vytváøí nìkteré metody.
\item \textbf{Obvykle pou¾ívané identifikátory} jako napøíklad promìnné \textit{result} nebo~\textit{i}.
\item \textbf{Obvykle pou¾ívané algoritmy} budou ve vìt¹inì pøipadech implementované stejným zpùsobem. Jako pøíklad zde lze uvést témìø libovolný øadící algoritmus.
\item \textbf{Spoleèný autor} jednoho nebo více programù mù¾e vytvoøit více rùzných verzí programù, které se mohou jevit jako plagiáty, proto¾e autor má tendenci psát kód svým nauèeným zpùsobem.
\item \textbf{Opsaný kód}, který jako jediný mù¾e být oznaèet jako plagiát, proto¾e zde do¹lo ke kopírování nebo transformaci cizího kódu bez patøièného uvedení jeho autora. 
\end{itemize}
\begin{center}
Figure 1.1: Zeidmanùv seznam ¹esti kategorií podobností kódu [odkaz na Bob Zeidman. What, exactly, is software plagiarism? Intellectual Property Today, 2007.]\cite{Pravidla}
\end{center}

Detekce plagiátorství na akademické úrovni sebou bohu¾el pøiná¹í je¹tì dal¹í problémy. Zadávané úkoly, hlavnì ty v~zaèatecnických kurzech programování bývají standardizované a velmi striktnì zadávané, co¾ mù¾e vyústit v~podobnì napsané programy, pøesto¾e studenti vypracovávali zadaný úkol samostatnì.

\section{Typy plagiátorství}
Jako plagiátorství oznaèujeme nejen jednoduché zkopírování zdrojového kódu, ale také jeho transformace. Tyto mohou být velice jednoduché jako pouhá zmìna, odebrání nebo pøidávání komentáøù, pøípadnì pøejmenováním promìnných, ale mohou být také komplikovanìj¹í jako tøeba zmìna struktury kódu tj. rùzné vnoøování funkcí nebo pøepsání {\tt for} cyklù na {\tt do-while} cykly. Pøípadnì je mo¾né, ¾e se autor mù¾e pokusit vyu¾ít modularity. Modularita nebo také rozèlenìní programu do nìkolika spolupracujicích modulù (souborù) je pøi práci na rozsáhlej¹ích projektech samozøejmostí. Tento prostøedek nicménì umo¾òuje plagiátorovi vhodnì schovat opsaný kód tak, ¾e prohodí funkce mezi jednotlivými moduly. J. A. W. Faidhi a S. K. Robinson podle tìchto pøedpokladù definovali ¹est úrovní plagiátorství zdrojového kódu (Figure 1.2) od~nejjednodu¹¹ích technik a¾ po ty nejslo¾itìj¹í.

\begin{itemize}
\item \textbf{Úroveò 1} - zmìna komentáøù ve zdrojovém kódu
\item \textbf{Úroveò 2} - zmìna názvu identifikátorù
\item \textbf{Úroveò 3} - zmìna pozice promìnných ve zdrojovém kódu
\item \textbf{Úroveò 4} - zmìna konstant a funkcí
\item \textbf{Úroveò 5} - zmìna cyklù
\item \textbf{Úroveò 6} - zmìna struktur urèených pro kontrolu toku programu
\end{itemize}
\begin{center}
Figure 1.2: Faidhi a Robinson definovali ¹est úrovní plagiátorství zdrojového kódu.[J. A. Faidhi and S. K. Robinson. An empirical approach for detecting program similarity and
plagiarism within a university programming environment. 1987.]
\end{center}

Tato práce je zamìøena na odhalení v¹ech ¹esti úrovní plagiátorství, pøièem¾ hlavní pozornost je vìnována prvním ètyøem úrovním, které by mìly být odhaleny v¾dy ji¾ pøi povrchním porovnávání zdrojových kódù.

\section{Jazyk PHP}
Jazyk PHP se ve své první formì objevil ji¾ v roce 1994, kdy se pan Rasmus Lerdorf rozhodl, ¾e vytvoøí jednoduchý systém, který bude zapoèítávat pøístup na webové stránky. První verze byla napsána v jazyce PERL, nicménì vzhledem ke znaènému zatí¾ení serveru bylo poté PHP pøepsáno do jazyka C. V prùbìhu let následovalo vydání nìkolika dal¹ích verzí, a¾ nakonec v~roce 2003 byla oficiálnì vydána beta verze PHP5, která pøinesla nejvìt¹í zmìnu v podobì pøidání objektového modelu.

Jazyk získal velké uplatnìní zejména z~dùvodu, ¾e je nezávislý na platformì a~rozdíly v~rùzných operaèních systémech se omezují pouze na nìkolik systémovì závislých funkcí. Nicménì stejnì jako ostatní jazyky, má i~PHP nevýhody. Nejvìt¹í nevýhodou je fakt, ¾e se jedná o~jazyk interpretovaný, co¾ znamená, ¾e pøi jakémkoliv spu¹tìní i~toho nejmen¹ího skriptu, je potøeba soubor s~tímto skriptem znovu kompilovat.

\subsection{Specifika jazyka PHP}
Jak ji¾ bylo uvedeno vý¹e, tak objektový model byl do jazyka pøidán a¾ pozdìji, co¾ nyní programátorùm umo¾òuje vybrat si, jestli budou své programy psát vyu¾ívajíc imperativního nebo objektovì orientovaného paradigmatu. Tento výbìr ov¹em také napomáhá ¹íøení plagiátorství, proto¾e lze pøepsáním originálního zdrojového kódu do jiného programovacího paradigmatu vytvoøit na první pohled odli¹ný kód.

\subsection{Kvalita kódu}
Jazyk PHP byl dlouho definován pouze svou implementací a~oficiální specifikace jazyka byla oznámena teprve na konci èervence 2014. Pokud k~tomuto pøipoèteme fakt, ¾e v~jazyku panuje nekonzistentní pojmenování funkcí, pøípadnì nejednotné poøadí parametrù ve funkcích a~vezmeme v~potaz i~to, ¾e jazyk samotný není obtí¾né se nauèit, dostaneme jako výsledek mnoho nekvalitního kódu.

Kvalitu zdrojového kódu lze podle Dr. Billa Curtise definovat jako pìtici po¾adovaných vlastností softwaru, nutných k~zaji¹tìní jeho obchodní hodnoty. Tento model byl pozdìji uveden jako CISQ model kvality. (Figure 1.3)
\begin{itemize}
\item \textbf{Spolehlivost} - Urèuje míru rizika a~pravdìpodobnosti pøípadných selhání aplikace.
\item \textbf{Efektivita} - Zdrojový kód a~jeho struktura jsou hlavními faktory, které urèují rychlost bìhu aplikace.
\item \textbf{Bezpeènost} - Metrika na urèení náchylnosti programu na prolomení bezpeènosti zapøíèinìné ¹patnými praktikami v~návrhu a~naprogramování aplikace.
\item \textbf{Udr¾ovatelnost} - Zahrnuje srozumitelnost a~pøenositelnost aplikace, jak mezi jednotlivými operaèními systémy, tak mezi jednotlivými vývojovými týmy.
\item \textbf{Velikost} - Aèkoliv velikost pøímo neovlivòuje kvalitu zdrojového kódu, tak stále má velký vliv na udr¾ovatelnost kódu a tedy nepøímo i na kvalitu výsledného kódu.  
\end{itemize}
\begin{center}
Figure 1.3: Definice kvality zdrojového kódu podle CISQ modelu[link na cisq]
\end{center}

\chapter{Analýza problému}
Jak ji¾ bylo naznaèeno v úvodu, plagiát zdrojového kódu mù¾eme definovat jako program, který byl vytvoøen z jiného programu s urèitým poètem transformací tak, aby na první pohled nebylo mo¾né poznat zdroj. Z toho vyplývá velmi dùle¾itý po¾adavek na vlastnost výsledného programu, tedy schopnost rozeznat plagiáty mezi projekty, které jsou pouze podobné, ale ne opsané.
K zaji¹tìní této vlastnosti, bylo vyu¾ito nìkolika rozdílných technik, které budou popsány ní¾e, tak aby program nalezl a vyznaèil plagiáty co mo¾ná nejpøesnìji a zárovìò neoznaèil projekty, které byly pouze v nìkterých ohledech podobné.

Základem pøi vyu¾ivání jakýchkoliv z následujících technik pro rozpoznání plagiátù je pokus o zredukování co mo¾ná nejvìt¹ího poètu nadbyteèných znakù, které samotné nemají vliv na samotný bìh programu. O toto se postará lexikální analýza pøi pøekladu zdrojového kódu, nicménì vzhledem k povaze na¹eho programu nejsou zdrojové kódy pøekládany a spou¹tìny a je nutno zajistit nìkteré funkce lexikální analýzy externì. První dùle¾itou funkcí, kterou musí lexikální analýza pro potøeby usnadnìní detekce plagiátù je odstranìní jakýchkoliv bílých znakù ze zdrojového textu. Druhou funkcí je transformovat zdrojový kód do posloupnosti tokenù. 

\section{Tokenizace}
Jedná se o proces, který provádí lexikální analyzátor pøi pøekladu programu. V jeho prùbìhu se naèítají ze vstupního zdrojového souboru znaky reprezentující zdrojový program a z tìchto znakù jsou následnì vytvoøeny symboly programu tzv. lexémy. Tyto lexémy jsou následnì reprezentovány ve formì tokenù, co¾ je øetìzec jednoho nebo více znakù, které jsou v daném jazdyce dùle¾ité jako skupina[%TODO
odkaz na list of parser tokens php]. 

Vyu¾ití tokenù pøi porovnávání zdrojových kódu má oproti porovnání pøímo zdrojových textù velikou výhodu v tom, ¾e ka¾dý token má v programu specifický význam a také hodnotu pùvodního øetìzce. Díky vyu¾ití této abstrakce, kdy se pomocí metod na detekci plagiátorství hledají plagiáty, lze ji¾ pøedem zajistit, aby pouhé pøejmenování promìnných a funkcí v~opsaném kódu neovlivnilo èinnost tìchto metod. Výslednou posloupnost tokenù lze dále pou¾ít jako vstup pro nìkteré techniky na detekci plagiátù, které budou uvedeny ní¾e. Dal¹í mo¾ností je z tokenù vytvoøit abstraktní syntaktický strom.

\section{Abstraktní syntaktický strom}
Jedná se o stromovou reprezentaci abstraktní syntaktické struktury zdrojového kódu napsaného v programovacím jazyce. Struktura tohoto stromu je zalo¾ena na principu, ¾e vnitøní uzly stromu jsou operátory a listy stromu jsou operandy. Tohoto stromu se v pøekladaèích vyu¾ívá zejména pro pøeklad a optimalizaci kódu nicménì díky tomu, ¾e ka¾dá èást podstromu je samostatnou logickou jednotkou lze pomocí algoritmù pro porovnávání stromových struktur zjistit podobnosti zdrojových kódu i pokud byl plagiát rùznì restrukturalizován. Samotná syntaxe stromu je èásteènì abstraktní, co¾ znamená, ¾e pøímo nereprezentuje ka¾dý detail, který se vyskytuje v reálné syntaxi. Jako pøíklad lze uvést slo¾ené závorky, které v jazyce PHP obalují syntaktické konstukce vìtvení {\tt if-else}, které mù¾e být ve stromu reprezentováno pouze jediným uzlem se dvìma vìtvemi.
\\ \\ \\
TODO: Obrázek AST pro eukliduv algoritmus
\\ \\ \\
Na obrázku 2.2.1[ %TODO link
link] je pøedvedena ukázka, jak vypadá abstraktní syntaktický strom pro Eukleidùv algoritmus. Na obrázku lze výbornì vidìt jistou míru abstrakce, kterou tyto stromy poskytytují.

\begin{verbatim}
function Euklid(int a, int b) {
   while b != 0 {
      if (a > b) {
         a = a - b;
      }
      else {
         b = b - a;
      }
   }
   return a;
}
\end{verbatim}
\begin{center}
Zdrojový kód pro Euklidùv algoritmus na výpoèet nejvìt¹ího spoleèného dìlitele.
\end{center}


\section{Halsteadova metrika}
Halsteadova metrika velikosti programu je softwarová metrika, kterou v roce 1977 pøedstavil Maurice H. Halstead. Je zalo¾ena na pøedpokladu, ¾e v¹echny programy se skládají z koneèného poètu programových jednotek, tzv. tokenù, které jsou rozeznatelné v syntaktické fázi pøekladaèem. Poèítaèový program poté mù¾e být brán jako posloupnost tìchto tokenù, které mohou být dále klasifikovány buï jako operátory nebo operandy. Cílem techniky bylo identifikovat takové vlastnosti programù, které by byly snadno vyèíslitelné, a které by mezi sebou mìli urèité souvislosti. Proto Halstead pro svoji metriku definoval ètyøi základní promìnné, ze kterých lze poté vypoèítat dal¹í metriky programu.

\begin{itemize}
\item \textbf{$\eta${$_1$}} = poèet unikátních operátorù
\item \textbf{$\eta${$_2$}} = poèet unikátních operandù
\item \textbf{N{$_1$}} = celkový poèet operátorù
\item \textbf{N{$_2$}} = celkový poèet operandù
\end{itemize}

Z tìchto èisel lze dále vypoèítat hned nìkolik základních metrik.

\begin{itemize}
\item \textbf{Délku slovníku:} $\eta$ = $\eta_1$ + $\eta_2$
\item \textbf{Délku programu:} $N = N_1 + N_2$
\item \textbf{Odhadnutou délku programu:} $N = \eta_1log\eta_1 + \eta_2log\eta_2$
\item \textbf{Objem:} $V = N*log_2\eta$
\item \textbf{Programovou nároènost:} $D = \frac{\eta_1}{2} * \frac{N_2}{\eta_2}$ 
\item \textbf{Programátorské úsilí:} $E = D * V$
\end{itemize}

Uva¾ujme následující funkci v jazyce PHP:
%TODO prepracovat kod
\begin{verbatim} 
function getAverage() {
fscanf(STDIN, "%d %d %d", $a, $b, $c);
$avg = ($a + $b + $c) / 3;
echo "avg = " . $avg;
}
\end{verbatim}

Unikátní operátory jsou následující: {\tt 'fscanf', '(', 'STDIN', '\%d \%d \%d', '\$a', '\$b', '\$c', ')', ';', '\$avg', '3', 'echo', 'avg = ' }\\ %TODO tady ma bejt mezera
Unikátní operandy jsou následující: {\tt ',', '=', '+', '/', '.'}

$\eta_1 = 13$, $\eta_2 = 5$\\
$N_1 = 20$, $N_2 = 9$\\
Délka slovníku: \\%TODO vypocet
Délka programu:\\
Odhadnutá délka programu: \\
Objem: \\
Programová nároènost:\\
Programátorské úsilí:\\

%TODO
\begin{center}
Pøíklad 2.1.1 
\end{center}

Výhodou pou¾ití této techniky k detekci plagiátorství je její rychlost. Halsteadova metrika pouze vypoèítá vý¹e uvedené metriky pro urèitý zadaný úsek kódu a poté staèi tyto hodnoty porovnat s metrikami získanými z jiných zdrojových kódu. Její velkou nevýhodou je nicménì fakt, ¾e je mo¾né získat dvì stejné metriky pro zcela rozdílnì pracující kusy kódu, které by byly následnì vyhodoceny jako plagiát. Proto byla tato technika vyu¾ita pouze jako odrazový mùstek pro èasovì nároènìj¹í techniky, aby se tyto mohly zabývat pouze projekty, u kterých jsou pøedpoklady k nalezení opsaných èástí zdrojového kódu.

\section{Levenshteinova vzdálenost}
Jedná se o jednu ze základních metrik k detekci plagiátorství textù zavedena v roce 1965 Vladimírem Levenshteinem.Vzdálenost dvou øetìzcù je zde definována jako minimální poèet operací vkládání, mazání a substituce takových, aby po jejich provedení byly zadané øetìzce toto¾né. Samotný zdrojový kód je pak pouze posloupnost øetìzcù, tak¾e není ¾ádný problém tento algoritmus aplikovat na dva rùzné zdrojové kódy a rozhodnout, jak jsou si podle tohoto algoritmu navzájem podobné.

Jako pøíklad Levenshteinovy vzdálenosti lze uvést tøeba anglická slova {\tt house} a {\tt router}. Jejich vzdálenost je tøi, proto¾e minimální poèet operací, které je potøeba provést k transformaci jednoho slova na druhé je právì tøi. Pokud bychom chtìli transformovat slovo {\tt house} na {\tt router}, staèí pouze ve slovì {\tt house} substituovat {\tt h} za {\tt r}, {\tt t} za {\tt s} a nakonec pouze pøidat na konec slova znak {\tt r}. %TODO tadz dat mozna jine zvyrazneni

\section{Otisky dokumentù}
Patøí mezi jednu z nejpou¾ívanìj¹ích metod pro detekci plagiátorství, kterou vyu¾ívají i nìkteré akademické instituce. Metoda funguje na principu identifikování nìkterých specifických øetìtcù v dokumentu a z nich vytvoøení unikátního otisku. Teoreticky by tak rozdílné dokumenty mìly v¾dy mít rozdílné otisky a stejnì tak, podobné dokumenty by mìly mít otisky podobné.

Vìt¹ina metod na tvorbu otiskù vyu¾ívá principu tzn. \textit{k-gramù}, kde \textit{k-gram} je sousedící podøetìzec o délce \textit{k}. Kód ní¾e demostruje pøíklad tvorby takového otisku dokumentu, kdy nejprve jsou odstranìny ze zdrojového kódu bílé znaky, posléze jsou vytvoøeny 5-gramy, na nì aplikována hashovací funkce a nakonec je z výsledku této hashovací funkce podle urèeného vzoru vybrán vzorek dat.

\begin{itemize} %TODO jiny seznam, nak to ocislovat
\item \begin{verbatim} 
public static String s = "Hello"; 
\end{verbatim}
\item publicstaticStrings="Hello";
\item publi ublic blics licst icsta cstat stati tatic aticS ticSt icStr cStri Strin tring rings ings= ngs=" gs="H s="He ="Hel "Hell Hello ello" llo";
\item 10701 11107 9382 10239 10003 9496 10975 11013 9314 11035 10000 9401 8022 11062 10851 10851 10034 10476 9860 10805 5742 3364 6960 9660 10306
\item 10701 10003 9314 8022 10034 5742 10306
\end{itemize}
\begin{center}
Figure 2.5.1 Otisk vzorového dokumentu
\end{center}

Nevýhodou celého øe¹ení je bohu¾el to, ¾e \textit{k-gram} sdílený dvìma dokumenty je nalezen pouze v pøípadì, ¾e je vybrán do kroku èíslo pìt, jak je vidìt na obrázku 2.5.1[link] %TODO link + zkontrolovat jestli nepisu kraviny o winnowingu
K pøekonání tohoto problému se vyu¾ívá algoritmus pro výbìr otiskù z k-\textit{k-gramù}, který z mno¾iny otiskù vybere nìkolik reprezentativních vzorkù tj. skupinu otiskù rozdìli na urèité úseky tzn. okna, které se nepøejkrývají. Z ka¾dého úseku je poté vybrán nejmen¹í otisk. 

Princip takovéto detekce plagiatorství spoèívá v lokálním charakteru tvorby otiskù. Zdrojový kód ovlivòuje jejich výbìr a je zaruèeno stejné zpracování pro rùzné dokumenty nehledì na to, zda se podobný kód objeví na ka¾dém desátém øádku, pouze na zaèátku souboru nebo náhodnì. V¾dy pokud se ve dvou dokumentech vyskytuje stejná posloupnost tokenù, z obou dvou bude vybrán stejný vzorek.

\chapter{Návrh øe¹ení}
Po analýze daného problému bych se v následující kapitole dál vìnoval jeho samotnému øe¹ení. Podrobnì bude popsána ka¾dá fáze, kterou budou zdrojové texty procházet. Celý program byl rozdìlen do nìkolika fází, které na sebe postupnì navazují, nicménì ka¾dá z nich má svùj samostatný výstup, který lze v nìkterých pøípadech pou¾ít jako vstup pro následující fáze programu. 

Pøed samotným zapoèetím samotné detekce je zapotøebí pøipravit projekty tak, aby bylo umo¾nìno jednoduché porovnávání zdrojových textù. Jak ji¾ bylo uvedeno v kapitole 1.2 [ %TODO link
] je potøeba zabránit schovávání opsaných èástí kódu do modulù. Vzhledem k tomu, ¾e výsledný kód nemusí být pro potøeby samotné detekce pøelo¾itelný, lze pøed zapoèetím prací spojit v¹echny moduly z projektù pomocí skriptu do jednoho. Tento jeden soubor je poté pøipraven ke zpracování pomocí lexikální analýzy.

\section{Lexikální analýza}
Lexikální analýza je èinnost, kterou provádí tzv. lexikální analyzátor a v jejím¾ prùbìhu se naèítají ze vstupního zdrojového souboru znaky reprezentující zdrojový program a z tìchto znakù jsou následnì vytvoøeny symboly programu tzv. lexémy. Tyto lexémy jsou následnì reprezentovány ve formì tokenù, co¾ je øetìzec jednoho nebo více znakù, které jsou v daném jazyce dùle¾ité jako skupina. Tento proces se nazývá tokenizace. V prùbìhu tokenizace je také pro zaji¹tìní rychlej¹í a pøesnìj¹í kontroly plagiátù potøeba odstranit ze zdrojového textu ve¹keré bílé znaky. Jakmile je tento proces ukonèen, posloupnost tokenù je serializována do formátu JSON a ulo¾ena do souboru pro dal¹í pou¾ití.

\section{Analýza tokenù}
V momentì kdy je vstupní soubor pøeveden do posloupnosti tokenù a serializován do struktury JSON, lze zaèít s jeho analýzou. Tato fáze probíhá v nìkolika krocích, které ov¹em v rámci efektivnosti algoritmu jsou provádìny souèasnì. V prùbehu analýzy je vhodné
\section{Halsteadova metrika}
\section{Levenstheinova vzdálenost}
\section{Porovnání abstraktních syntaktických stromù}
\section{Metoda winnowing}
\section{Øízení programu}

\chapter{Experimenty}

\chapter{Výsledky a zhodnocení práce}
\section{Testování a statistiky}
\section{Návrhy na roz¹íøení}




\chapter{Závìr}
Závìreèná kapitola obsahuje zhodnocení dosa¾ených výsledkù se zvlá¹» vyznaèeným vlastním pøínosem studenta. Povinnì se zde objeví i zhodnocení z pohledu dal¹ího vývoje projektu, student uvede námìty vycházející ze zku¹eností s øe¹eným projektem a uvede rovnì¾ návaznosti na právì dokonèené projekty.

%=========================================================================
